// renderer_exports.cpp
// Native Vulkan device + simple line renderer (exports used by C# P/Invoke)

#define RENDERERNATIVE_BUILD 1
#include "renderer_api.h"

// ===== Windows / Vulkan platform setup =====
#ifdef _WIN32
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef VK_USE_PLATFORM_WIN32_KHR
#define VK_USE_PLATFORM_WIN32_KHR
#endif
#include <windows.h>
#pragma comment(lib, "vulkan-1.lib")

#endif

#include <vulkan/vulkan.h>

#include <vector>
#include <string>
#include <cstring>
#include <cstdint>
#include <cstdio>

// ===== shader blobs (generated by your build) =====
static const uint32_t VS_SPV[] = {
#   include "vs_world_lines.spv.inc"          // if Shaders is in Additional Include Dirs
    // #   include "shaders/vs_world_lines.spv.inc" // use this form if it is NOT
};

static const uint32_t FS_SPV[] = {
#   include "fs_solid_color.spv.inc"
    // #   include "shaders/fs_solid_color.spv.inc"
};

static_assert(sizeof(VS_SPV) % 4 == 0, "VS_SPV must be dword-aligned");
static_assert(sizeof(FS_SPV) % 4 == 0, "FS_SPV must be dword-aligned");

// ===== last error / logging =====
static thread_local std::string g_last_error;
static const char* FW_CALL get_last_error_impl() { return g_last_error.c_str(); }

static fw_log_fn g_log_cb = nullptr;
static void* g_log_user = nullptr;

static void log_msg(int level, const char* msg) {
    if (g_log_cb) g_log_cb(level, msg, g_log_user);
}

// ===== helpers =====
static uint32_t find_memtype(VkPhysicalDevice phys, uint32_t type_bits, VkMemoryPropertyFlags want) {
    VkPhysicalDeviceMemoryProperties mp{};
    vkGetPhysicalDeviceMemoryProperties(phys, &mp);
    for (uint32_t i = 0; i < mp.memoryTypeCount; ++i)
        if ((type_bits & (1u << i)) && (mp.memoryTypes[i].propertyFlags & want) == want)
            return i;
    return UINT32_MAX;
}

static bool pick_graphics_queue_family(VkPhysicalDevice pd, uint32_t& family) {
    uint32_t count = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(pd, &count, nullptr);
    if (!count) return false;
    std::vector<VkQueueFamilyProperties> props(count);
    vkGetPhysicalDeviceQueueFamilyProperties(pd, &count, props.data());
    for (uint32_t i = 0; i < count; ++i)
        if (props[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) { family = i; return true; }
    return false;
}

static bool supports_present(VkPhysicalDevice pd, uint32_t family, VkSurfaceKHR surface) {
    VkBool32 sup = VK_FALSE;
    vkGetPhysicalDeviceSurfaceSupportKHR(pd, family, surface, &sup);
    return sup == VK_TRUE;
}

static VkSurfaceFormatKHR choose_surface_format(const std::vector<VkSurfaceFormatKHR>& formats) {
    // If the surface returns empty (shouldn’t, but defensive), choose a sensible default.
    if (formats.empty()) {
        VkSurfaceFormatKHR f{};
        f.format = VK_FORMAT_B8G8R8A8_UNORM;
        f.colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
        return f;
    }
    // If it returns a single UNDEFINED, we can choose what we like.
    if (formats.size() == 1 && formats[0].format == VK_FORMAT_UNDEFINED) {
        VkSurfaceFormatKHR f{};
        f.format = VK_FORMAT_B8G8R8A8_UNORM;
        f.colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
        return f;
    }
    for (auto& f : formats) {
        if ((f.format == VK_FORMAT_B8G8R8A8_UNORM || f.format == VK_FORMAT_B8G8R8A8_SRGB) &&
            f.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
            return f;
    }
    return formats[0];
}

// Prefer FIFO (always available). Try MAILBOX for low-latency if present.
static VkPresentModeKHR choose_present_mode(const std::vector<VkPresentModeKHR>& modes) {
    for (auto m : modes) if (m == VK_PRESENT_MODE_MAILBOX_KHR) return m;
    return VK_PRESENT_MODE_FIFO_KHR;
}

static VkExtent2D choose_extent(const VkSurfaceCapabilitiesKHR& caps, HWND hwnd) {
    if (caps.currentExtent.width != UINT32_MAX) return caps.currentExtent;
    RECT rc{}; GetClientRect(hwnd, &rc);
    VkExtent2D e{ (uint32_t)(rc.right - rc.left), (uint32_t)(rc.bottom - rc.top) };
    if (e.width < caps.minImageExtent.width)  e.width = caps.minImageExtent.width;
    if (e.height < caps.minImageExtent.height) e.height = caps.minImageExtent.height;
    if (e.width > caps.maxImageExtent.width)  e.width = caps.maxImageExtent.width;
    if (e.height > caps.maxImageExtent.height) e.height = caps.maxImageExtent.height;
    return e;
}

// ===== device state =====
struct Device {
    VkInstance       instance = VK_NULL_HANDLE;
    VkPhysicalDevice phys = VK_NULL_HANDLE;
    VkDevice         device = VK_NULL_HANDLE;
    uint32_t         gfxFam = 0xFFFFFFFF;
    VkQueue          gfxQ = VK_NULL_HANDLE;

    VkSurfaceKHR     surface = VK_NULL_HANDLE;
    VkSwapchainKHR   swap = VK_NULL_HANDLE;
    VkFormat         swapFmt = VK_FORMAT_B8G8R8A8_UNORM;
    VkExtent2D       extent{ 0,0 };
    std::vector<VkImage>     images;
    std::vector<VkImageView> views;

    VkRenderPass                 rp = VK_NULL_HANDLE;
    std::vector<VkFramebuffer>   fbs;

    VkCommandPool                cmdPool = VK_NULL_HANDLE;
    std::vector<VkCommandBuffer> cbs;
    VkSemaphore semAcquire = VK_NULL_HANDLE;
    VkSemaphore semRender = VK_NULL_HANDLE;
    VkFence     fence = VK_NULL_HANDLE;
    uint32_t    curImg = 0;

    // line pipeline + buffer
    VkPipelineLayout layout = VK_NULL_HANDLE;
    VkPipeline       pipe = VK_NULL_HANDLE;

    VkBuffer         vbuf = VK_NULL_HANDLE;
    VkDeviceMemory   vmem = VK_NULL_HANDLE;
    size_t           vcap = 0; // bytes
    size_t           vused = 0; // bytes used this frame
    void* mapped = nullptr;

    float            color[4]{ 1,1,1,1 };
};

// fw_handle (void*) <-> pointer helpers
static inline Device* H2D(fw_handle h) { return reinterpret_cast<Device*>(h); }
static inline fw_handle D2H(Device* p) { return reinterpret_cast<fw_handle>(p); }

// ===== pipeline + buffer creation =====
static bool create_lines_pipeline(Device* d) {
    VkPushConstantRange pcr{};
    pcr.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pcr.offset = 0; pcr.size = sizeof(float) * 4;

    VkPipelineLayoutCreateInfo plci{ VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO };
    plci.pushConstantRangeCount = 1; plci.pPushConstantRanges = &pcr;
    if (vkCreatePipelineLayout(d->device, &plci, nullptr, &d->layout) != VK_SUCCESS) return false;

    VkShaderModuleCreateInfo smci{ VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO };
    smci.codeSize = sizeof(VS_SPV); smci.pCode = VS_SPV;
    VkShaderModule vs = VK_NULL_HANDLE;
    if (vkCreateShaderModule(d->device, &smci, nullptr, &vs) != VK_SUCCESS) return false;

    smci.codeSize = sizeof(FS_SPV); smci.pCode = FS_SPV;
    VkShaderModule fs = VK_NULL_HANDLE;
    if (vkCreateShaderModule(d->device, &smci, nullptr, &fs) != VK_SUCCESS) {
        vkDestroyShaderModule(d->device, vs, nullptr);
        return false;
    }

    VkPipelineShaderStageCreateInfo stages[2]{};
    stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;   stages[0].module = vs; stages[0].pName = "main";
    stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT; stages[1].module = fs; stages[1].pName = "main";

    VkVertexInputBindingDescription bind{}; bind.binding = 0; bind.stride = sizeof(float) * 2; bind.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    VkVertexInputAttributeDescription attr{}; attr.location = 0; attr.binding = 0; attr.format = VK_FORMAT_R32G32_SFLOAT; attr.offset = 0;

    VkPipelineVertexInputStateCreateInfo vi{ VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO };
    vi.vertexBindingDescriptionCount = 1; vi.pVertexBindingDescriptions = &bind;
    vi.vertexAttributeDescriptionCount = 1; vi.pVertexAttributeDescriptions = &attr;

    VkPipelineInputAssemblyStateCreateInfo ia{ VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO };
    ia.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    VkViewport vp{ 0.f, 0.f, (float)d->extent.width, (float)d->extent.height, 0.f, 1.f };
    VkRect2D   sc{ {0,0}, d->extent };
    VkPipelineViewportStateCreateInfo vpci{ VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO };
    vpci.viewportCount = 1; vpci.pViewports = &vp; vpci.scissorCount = 1; vpci.pScissors = &sc;

    VkPipelineRasterizationStateCreateInfo rs{ VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO };
    rs.polygonMode = VK_POLYGON_MODE_FILL; rs.cullMode = VK_CULL_MODE_NONE; rs.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; rs.lineWidth = 1.0f;

    VkPipelineMultisampleStateCreateInfo ms{ VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO };
    ms.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineColorBlendAttachmentState cba{};
    cba.colorWriteMask =
        VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;

    VkPipelineColorBlendStateCreateInfo cb{ VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO };
    cb.attachmentCount = 1; cb.pAttachments = &cba;

    VkGraphicsPipelineCreateInfo gp{ VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO };
    gp.stageCount = 2; gp.pStages = stages;
    gp.pVertexInputState = &vi; gp.pInputAssemblyState = &ia; gp.pViewportState = &vpci;
    gp.pRasterizationState = &rs; gp.pMultisampleState = &ms; gp.pColorBlendState = &cb;
    gp.layout = d->layout; gp.renderPass = d->rp; gp.subpass = 0;

    VkPipeline pipe = VK_NULL_HANDLE;
    VkResult pr = vkCreateGraphicsPipelines(d->device, VK_NULL_HANDLE, 1, &gp, nullptr, &pipe);

    vkDestroyShaderModule(d->device, vs, nullptr);
    vkDestroyShaderModule(d->device, fs, nullptr);

    if (pr != VK_SUCCESS) return false;
    d->pipe = pipe;
    return true;
}

static bool create_vertex_buffer(Device* d, size_t min_bytes) {
    if (min_bytes < 65536) min_bytes = 65536;

    VkBufferCreateInfo bi{ VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
    bi.size = min_bytes; bi.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; bi.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    if (vkCreateBuffer(d->device, &bi, nullptr, &d->vbuf) != VK_SUCCESS) return false;

    VkMemoryRequirements mr{}; vkGetBufferMemoryRequirements(d->device, d->vbuf, &mr);
    uint32_t type = find_memtype(d->phys, mr.memoryTypeBits,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
    if (type == UINT32_MAX) return false;

    VkMemoryAllocateInfo mai{ VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
    mai.allocationSize = mr.size; mai.memoryTypeIndex = type;
    if (vkAllocateMemory(d->device, &mai, nullptr, &d->vmem) != VK_SUCCESS) return false;
    if (vkBindBufferMemory(d->device, d->vbuf, d->vmem, 0) != VK_SUCCESS) return false;
    if (vkMapMemory(d->device, d->vmem, 0, mr.size, 0, &d->mapped) != VK_SUCCESS) return false;

    d->vcap = mr.size; d->vused = 0;
    return true;
}

// ===== API functions =====
static void FW_CALL set_logger_impl(fw_log_fn fn, void* user) {
    g_log_cb = fn; g_log_user = user;
    log_msg(1, "Logger installed (ABI v3).");
}

// lines_upload: xy = float[x0,y0,x1,y1,...] (count = number of floats)
static int FW_CALL lines_upload_dev(fw_handle hdev, const float* xy, uint32_t count,
    float r, float g, float b, float a)
{
    Device* d = H2D(hdev);
    if (!d) { g_last_error = "null device"; return -1; }
    if (!xy || count == 0) return 0;

    const size_t bytes = size_t(count) * sizeof(float);
    if (bytes > d->vcap) { g_last_error = "lines buffer overflow"; return -2; }

    std::memcpy(d->mapped, xy, bytes);
    d->vused = bytes;
    d->color[0] = r; d->color[1] = g; d->color[2] = b; d->color[3] = a;
    return 0;
}

static int create_device_core(HWND hwnd, fw_handle* out) {
    *out = nullptr;

    // -------- Instance
    const char* instExts[] = { VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_WIN32_SURFACE_EXTENSION_NAME };

    VkApplicationInfo app{ VK_STRUCTURE_TYPE_APPLICATION_INFO };
    app.pApplicationName = "SolarFramework";
    app.apiVersion = VK_API_VERSION_1_2;

    VkInstanceCreateInfo ici{ VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO };
    ici.pApplicationInfo = &app;
    ici.enabledExtensionCount = (uint32_t)(sizeof(instExts) / sizeof(instExts[0]));
    ici.ppEnabledExtensionNames = instExts;

    VkInstance instance = VK_NULL_HANDLE;
    if (vkCreateInstance(&ici, nullptr, &instance) != VK_SUCCESS) { g_last_error = "vkCreateInstance failed"; return -1; }
    log_msg(1, "[native] Vulkan: Instance created.");

    // -------- Surface
    VkWin32SurfaceCreateInfoKHR sci{ VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR };
    sci.hinstance = (HINSTANCE)GetModuleHandleW(nullptr);
    sci.hwnd = hwnd;

    VkSurfaceKHR surface = VK_NULL_HANDLE;
    if (vkCreateWin32SurfaceKHR(instance, &sci, nullptr, &surface) != VK_SUCCESS) {
        g_last_error = "vkCreateWin32SurfaceKHR failed";
        vkDestroyInstance(instance, nullptr);
        return -2;
    }

    // -------- Physical + queue
    uint32_t n = 0; vkEnumeratePhysicalDevices(instance, &n, nullptr);
    if (!n) {
        g_last_error = "No GPUs";
        vkDestroySurfaceKHR(instance, surface, nullptr);
        vkDestroyInstance(instance, nullptr);
        return -3;
    }
    std::vector<VkPhysicalDevice> devs(n); vkEnumeratePhysicalDevices(instance, &n, devs.data());

    VkPhysicalDevice phys = VK_NULL_HANDLE; uint32_t fam = 0xFFFFFFFF;
    for (auto pd : devs) {
        uint32_t tmp;
        if (pick_graphics_queue_family(pd, tmp) && supports_present(pd, tmp, surface)) { phys = pd; fam = tmp; break; }
    }
    if (!phys) {
        g_last_error = "No device with graphics+present";
        vkDestroySurfaceKHR(instance, surface, nullptr);
        vkDestroyInstance(instance, nullptr);
        return -4;
    }

    // -------- Logical device
    float prio = 1.f;
    VkDeviceQueueCreateInfo qci{ VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO };
    qci.queueFamilyIndex = fam; qci.queueCount = 1; qci.pQueuePriorities = &prio;

    const char* devExts[] = { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
    VkDeviceCreateInfo dci{ VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO };
    dci.queueCreateInfoCount = 1; dci.pQueueCreateInfos = &qci;
    dci.enabledExtensionCount = (uint32_t)(sizeof(devExts) / sizeof(devExts[0]));
    dci.ppEnabledExtensionNames = devExts;

    VkDevice device = VK_NULL_HANDLE;
    if (vkCreateDevice(phys, &dci, nullptr, &device) != VK_SUCCESS) {
        g_last_error = "vkCreateDevice failed";
        vkDestroySurfaceKHR(instance, surface, nullptr);
        vkDestroyInstance(instance, nullptr);
        return -5;
    }
    VkQueue q = VK_NULL_HANDLE; vkGetDeviceQueue(device, fam, 0, &q);

    // -------- Swapchain plumbing
    VkSurfaceCapabilitiesKHR caps{};
    if (vkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys, surface, &caps) != VK_SUCCESS) {
        g_last_error = "vkGetPhysicalDeviceSurfaceCapabilitiesKHR failed";
        vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -6;
    }

    uint32_t fmtCount = 0, pmCount = 0;
    vkGetPhysicalDeviceSurfaceFormatsKHR(phys, surface, &fmtCount, nullptr);
    std::vector<VkSurfaceFormatKHR> formats(fmtCount);
    if (fmtCount) vkGetPhysicalDeviceSurfaceFormatsKHR(phys, surface, &fmtCount, formats.data());

    vkGetPhysicalDeviceSurfacePresentModesKHR(phys, surface, &pmCount, nullptr);
    std::vector<VkPresentModeKHR> modes(pmCount);
    if (pmCount) vkGetPhysicalDeviceSurfacePresentModesKHR(phys, surface, &pmCount, modes.data());

    VkSurfaceFormatKHR sf = choose_surface_format(formats);
    VkPresentModeKHR   pm = choose_present_mode(modes);
    VkExtent2D         ex = choose_extent(caps, hwnd);

    uint32_t imgCount = caps.minImageCount + 1;
    if (caps.maxImageCount && imgCount > caps.maxImageCount) imgCount = caps.maxImageCount;
    if (imgCount < caps.minImageCount) imgCount = caps.minImageCount ? caps.minImageCount : 2;

    VkSwapchainCreateInfoKHR sci2{ VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR };
    sci2.surface = surface; sci2.minImageCount = imgCount; sci2.imageFormat = sf.format; sci2.imageColorSpace = sf.colorSpace;
    sci2.imageExtent = ex; sci2.imageArrayLayers = 1; sci2.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    sci2.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; sci2.preTransform = caps.currentTransform;
    sci2.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    sci2.presentMode = pm; sci2.clipped = VK_TRUE;

    VkSwapchainKHR swap = VK_NULL_HANDLE;
    if (vkCreateSwapchainKHR(device, &sci2, nullptr, &swap) != VK_SUCCESS) {
        g_last_error = "vkCreateSwapchainKHR failed";
        vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -7;
    }

    uint32_t ic = 0; vkGetSwapchainImagesKHR(device, swap, &ic, nullptr);
    if (!ic) {
        g_last_error = "Swapchain returned zero images";
        vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -8;
    }

    std::vector<VkImage> imgs(ic); vkGetSwapchainImagesKHR(device, swap, &ic, imgs.data());
    std::vector<VkImageView> views(ic);

    for (uint32_t i = 0; i < ic; ++i) {
        VkImageViewCreateInfo iv{ VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO };
        iv.image = imgs[i]; iv.viewType = VK_IMAGE_VIEW_TYPE_2D; iv.format = sf.format;
        iv.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        iv.subresourceRange.levelCount = 1; iv.subresourceRange.layerCount = 1;
        if (vkCreateImageView(device, &iv, nullptr, &views[i]) != VK_SUCCESS) {
            g_last_error = "vkCreateImageView failed";
            for (uint32_t j = 0; j < i; ++j) vkDestroyImageView(device, views[j], nullptr);
            vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
            return -9;
        }
    }

    // -------- Render pass + framebuffers
    VkAttachmentDescription color{};
    color.format = sf.format; color.samples = VK_SAMPLE_COUNT_1_BIT;
    color.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; color.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    color.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; color.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentReference cref{ 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };
    VkSubpassDescription sub{}; sub.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    sub.colorAttachmentCount = 1; sub.pColorAttachments = &cref;

    VkSubpassDependency dep{};
    dep.srcSubpass = VK_SUBPASS_EXTERNAL; dep.dstSubpass = 0;
    dep.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dep.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dep.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

    VkRenderPassCreateInfo rpci{ VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO };
    rpci.attachmentCount = 1; rpci.pAttachments = &color;
    rpci.subpassCount = 1; rpci.pSubpasses = &sub;
    rpci.dependencyCount = 1; rpci.pDependencies = &dep;

    VkRenderPass rp = VK_NULL_HANDLE;
    if (vkCreateRenderPass(device, &rpci, nullptr, &rp) != VK_SUCCESS) {
        g_last_error = "vkCreateRenderPass failed";
        for (auto v : views) vkDestroyImageView(device, v, nullptr);
        vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -10;
    }

    std::vector<VkFramebuffer> fbs(ic);
    for (uint32_t i = 0; i < ic; ++i) {
        VkImageView att[]{ views[i] };
        VkFramebufferCreateInfo fbci{ VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO };
        fbci.renderPass = rp; fbci.attachmentCount = 1; fbci.pAttachments = att;
        fbci.width = ex.width; fbci.height = ex.height; fbci.layers = 1;
        if (vkCreateFramebuffer(device, &fbci, nullptr, &fbs[i]) != VK_SUCCESS) {
            g_last_error = "vkCreateFramebuffer failed";
            for (uint32_t j = 0; j < i; ++j) vkDestroyFramebuffer(device, fbs[j], nullptr);
            vkDestroyRenderPass(device, rp, nullptr);
            for (auto v : views) vkDestroyImageView(device, v, nullptr);
            vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
            return -11;
        }
    }

    // -------- Commands + sync
    VkCommandPoolCreateInfo cpci{ VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO };
    cpci.queueFamilyIndex = fam;

    VkCommandPool pool = VK_NULL_HANDLE;
    if (vkCreateCommandPool(device, &cpci, nullptr, &pool) != VK_SUCCESS) {
        g_last_error = "vkCreateCommandPool failed";
        for (auto fb : fbs) vkDestroyFramebuffer(device, fb, nullptr);
        vkDestroyRenderPass(device, rp, nullptr);
        for (auto v : views) vkDestroyImageView(device, v, nullptr);
        vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -12;
    }

    std::vector<VkCommandBuffer> cbs(ic);
    VkCommandBufferAllocateInfo cbai{ VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO };
    cbai.commandPool = pool; cbai.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; cbai.commandBufferCount = ic;
    if (vkAllocateCommandBuffers(device, &cbai, cbs.data()) != VK_SUCCESS) {
        g_last_error = "vkAllocateCommandBuffers failed";
        vkDestroyCommandPool(device, pool, nullptr);
        for (auto fb : fbs) vkDestroyFramebuffer(device, fb, nullptr);
        vkDestroyRenderPass(device, rp, nullptr);
        for (auto v : views) vkDestroyImageView(device, v, nullptr);
        vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -13;
    }

    VkSemaphoreCreateInfo sciS{ VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO };
    VkFenceCreateInfo fci{ VK_STRUCTURE_TYPE_FENCE_CREATE_INFO }; fci.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    VkSemaphore semA = VK_NULL_HANDLE, semB = VK_NULL_HANDLE; VkFence fence = VK_NULL_HANDLE;
    if (vkCreateSemaphore(device, &sciS, nullptr, &semA) != VK_SUCCESS ||
        vkCreateSemaphore(device, &sciS, nullptr, &semB) != VK_SUCCESS ||
        vkCreateFence(device, &fci, nullptr, &fence) != VK_SUCCESS)
    {
        g_last_error = "sync creation failed";
        if (fence) vkDestroyFence(device, fence, nullptr);
        if (semB)  vkDestroySemaphore(device, semB, nullptr);
        if (semA)  vkDestroySemaphore(device, semA, nullptr);
        vkDestroyCommandPool(device, pool, nullptr);
        for (auto fb : fbs) vkDestroyFramebuffer(device, fb, nullptr);
        vkDestroyRenderPass(device, rp, nullptr);
        for (auto v : views) vkDestroyImageView(device, v, nullptr);
        vkDestroySwapchainKHR(device, swap, nullptr); vkDestroyDevice(device, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr);
        return -14;
    }

    // -------- create renderer state
    auto* d = new Device();
    d->instance = instance; d->phys = phys; d->device = device; d->gfxFam = fam; d->gfxQ = q;
    d->surface = surface; d->swap = swap; d->swapFmt = sf.format; d->extent = ex;
    d->images = std::move(imgs); d->views = std::move(views);
    d->rp = rp; d->fbs = std::move(fbs);
    d->cmdPool = pool; d->cbs = std::move(cbs);
    d->semAcquire = semA; d->semRender = semB; d->fence = fence;

    // Try to set up the simple line pipeline; if it fails, keep the device so clears still show
    if (!create_lines_pipeline(d) || !create_vertex_buffer(d, 1 << 20)) {
        g_last_error = "lines pipeline/buffer failed (continuing with clears only)";
        // non-fatal
    }

    *out = D2H(d);
    log_msg(1, "[native] Vulkan: swapchain + lines pipeline ready.");
    return 0;
}

static int FW_CALL create_device(const fw_renderer_desc* desc, fw_handle* out) {
    if (!desc || !desc->hwnd) { g_last_error = "Null HWND"; return -100; }

    // SEH guard so the managed side never sees a hard AV
    __try {
        return create_device_core((HWND)(uintptr_t)desc->hwnd, out);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        g_last_error = "SEH: access violation in create_device";
        *out = nullptr;
        return -9999;
    }
}

static void FW_CALL destroy_device(fw_handle h) {
    auto* d = H2D(h); if (!d) return;
    vkDeviceWaitIdle(d->device);

    if (d->vmem)   vkUnmapMemory(d->device, d->vmem);
    if (d->vbuf)   vkDestroyBuffer(d->device, d->vbuf, nullptr);
    if (d->vmem)   vkFreeMemory(d->device, d->vmem, nullptr);
    if (d->pipe)   vkDestroyPipeline(d->device, d->pipe, nullptr);
    if (d->layout) vkDestroyPipelineLayout(d->device, d->layout, nullptr);

    if (d->fence)      vkDestroyFence(d->device, d->fence, nullptr);
    if (d->semRender)  vkDestroySemaphore(d->device, d->semRender, nullptr);
    if (d->semAcquire) vkDestroySemaphore(d->device, d->semAcquire, nullptr);

    for (auto fb : d->fbs) vkDestroyFramebuffer(d->device, fb, nullptr);
    if (d->rp) vkDestroyRenderPass(d->device, d->rp, nullptr);

    for (auto v : d->views) vkDestroyImageView(d->device, v, nullptr);
    if (d->swap)    vkDestroySwapchainKHR(d->device, d->swap, nullptr);
    if (d->cmdPool) vkDestroyCommandPool(d->device, d->cmdPool, nullptr);
    if (d->surface) vkDestroySurfaceKHR(d->instance, d->surface, nullptr);
    if (d->device)  vkDestroyDevice(d->device, nullptr);
    if (d->instance)vkDestroyInstance(d->instance, nullptr);

    delete d;
    log_msg(1, "[native] Vulkan: Device destroyed.");
}

static void FW_CALL begin_frame(fw_handle h) {
    auto* d = H2D(h); if (!d) return;

    vkWaitForFences(d->device, 1, &d->fence, VK_TRUE, UINT64_MAX);
    vkResetFences(d->device, 1, &d->fence);

    uint32_t idx = 0;
    VkResult ra = vkAcquireNextImageKHR(d->device, d->swap, UINT64_MAX, d->semAcquire, VK_NULL_HANDLE, &idx);

    // If out-of-date (resize/minimize), skip this frame. SUBOPTIMAL is fine.
    if (ra == VK_ERROR_OUT_OF_DATE_KHR) return;
    if (ra != VK_SUCCESS && ra != VK_SUBOPTIMAL_KHR) {
        g_last_error = "AcquireNextImageKHR failed";
        return;
    }

    d->curImg = idx;

    VkCommandBuffer cb = d->cbs[idx];
    VkCommandBufferBeginInfo bi{ VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO };
    vkBeginCommandBuffer(cb, &bi);

    VkClearValue clear; clear.color = { {0.02f,0.03f,0.05f,1.f} };
    VkRenderPassBeginInfo rbi{ VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO };
    rbi.renderPass = d->rp; rbi.framebuffer = d->fbs[idx];
    rbi.renderArea = { {0,0}, d->extent }; rbi.clearValueCount = 1; rbi.pClearValues = &clear;

    vkCmdBeginRenderPass(cb, &rbi, VK_SUBPASS_CONTENTS_INLINE);

    if (d->pipe && d->vused >= sizeof(float) * 2) {
        VkDeviceSize off = 0;
        vkCmdBindPipeline(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, d->pipe);
        vkCmdBindVertexBuffers(cb, 0, 1, &d->vbuf, &off);
        vkCmdPushConstants(cb, d->layout, VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(float) * 4, d->color);
        uint32_t vtx = (uint32_t)(d->vused / (sizeof(float) * 2));
        vkCmdDraw(cb, vtx, 1, 0, 0);
    }

    vkCmdEndRenderPass(cb);
    vkEndCommandBuffer(cb);
}

static void FW_CALL end_frame(fw_handle h) {
    auto* d = H2D(h); if (!d) return;

    VkCommandBuffer cb = d->cbs[d->curImg];
    VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;

    VkSubmitInfo si{ VK_STRUCTURE_TYPE_SUBMIT_INFO };
    si.waitSemaphoreCount = 1; si.pWaitSemaphores = &d->semAcquire; si.pWaitDstStageMask = &waitStage;
    si.commandBufferCount = 1; si.pCommandBuffers = &cb;
    si.signalSemaphoreCount = 1; si.pSignalSemaphores = &d->semRender;
    vkQueueSubmit(d->gfxQ, 1, &si, d->fence);

    VkPresentInfoKHR pi{ VK_STRUCTURE_TYPE_PRESENT_INFO_KHR };
    VkSwapchainKHR sw = d->swap; uint32_t idx = d->curImg;
    pi.waitSemaphoreCount = 1; pi.pWaitSemaphores = &d->semRender;
    pi.swapchainCount = 1; pi.pSwapchains = &sw; pi.pImageIndices = &idx;

    // Treat SUBOPTIMAL as success; ignore OUT_OF_DATE here (recreate on next BeginFrame if desired).
    (void)vkQueuePresentKHR(d->gfxQ, &pi);

    d->vused = 0; // reset per frame
}

// ====== exported ABI table (v3) ======
static fw_renderer_api g_api;

extern "C" FW_EXPORT const fw_renderer_api* FW_CALL fwGetRendererAPI(void) {
    g_api.abi = 3;
    g_api.get_last_error = &get_last_error_impl;
    g_api.set_logger = &set_logger_impl;
    g_api.create_device = &create_device;
    g_api.destroy_device = &destroy_device;
    g_api.begin_frame = &begin_frame;
    g_api.end_frame = &end_frame;
    g_api.lines_upload = &lines_upload_dev;
    return &g_api;
}

// ====== simple C exports (for direct P/Invoke) ======
extern "C" FW_EXPORT uint32_t     FW_CALL fwGetABI(void) { return 3; }
extern "C" FW_EXPORT const char* FW_CALL fwGetLastError(void) { return get_last_error_impl(); }
extern "C" FW_EXPORT void         FW_CALL fwSetLogger(fw_log_fn fn, void* user) { set_logger_impl(fn, user); }

extern "C" FW_EXPORT int          FW_CALL fwCreateDeviceSimple(uint64_t hwnd, fw_handle* out_dev) {
    fw_renderer_desc d{ hwnd };
    return create_device(&d, out_dev);
}
extern "C" FW_EXPORT void         FW_CALL fwDestroyDevice(fw_handle dev) { destroy_device(dev); }
extern "C" FW_EXPORT void         FW_CALL fwBeginFrame(fw_handle dev) { begin_frame(dev); }
extern "C" FW_EXPORT void         FW_CALL fwEndFrame(fw_handle dev) { end_frame(dev); }
extern "C" FW_EXPORT int          FW_CALL fwLinesUpload(fw_handle dev, const float* xy, uint32_t count,
    float r, float g, float b, float a)
{
    return lines_upload_dev(dev, xy, count, r, g, b, a);
}
